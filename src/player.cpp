
#include "player.hpp"
#include "config.hpp"
#include "wasm4.h"


uint8_t const SPRITE_FWD_[64] = {
    0xff,0xf0,0x0f,0xff,0xff,0xc5,0x53,0xff,0xff,0x1a,0xa4,0xff,0xff,0x20,0x08,0xff,0xfc,0x80,0x02,0x3f,0xfc,0x88,0x22,0x3f,0xf0,0x40,0x01,0x0f,0xf1,0x20,0x08,0x4f,0xf1,0x59,0x65,0x4f,0xf1,0x16,0x94,0x4f,0xca,0x15,0x54,0xa3,0xc0,0x15,0x54,0x03,0xf0,0x55,0x55,0x0f,0xfc,0x45,0x51,0x3f,0xff,0x05,0x50,0xff,0xff,0xf0,0x0f,0xff
};

uint8_t const SPRITE_RIGHT_[64] = {
    0xff,0xff,0x00,0xff,0xff,0xf0,0x55,0x3f,0xff,0xc5,0x6a,0x3f,0xff,0x15,0x80,0xff,0xff,0x16,0x00,0xff,0xff,0xc6,0x20,0xff,0xff,0x12,0x00,0xff,0xfc,0x54,0x00,0xff,0xfc,0x46,0x01,0x3f,0xfc,0x45,0x91,0x3f,0xf2,0x85,0x60,0x3f,0xf0,0x05,0x54,0xff,0xfc,0x15,0x54,0xff,0xfc,0x51,0x54,0xff,0xfc,0x11,0x43,0xff,0xff,0xc0,0x3f,0xff
};

uint8_t const SPRITE_BACK_[64] = {
    0xff,0xf0,0x0f,0xff,0xff,0xca,0xa3,0xff,0xff,0x25,0x58,0xff,0xff,0x15,0x54,0xff,0xfc,0x55,0x55,0x3f,0xfc,0x45,0x51,0x3f,0xfc,0x10,0x04,0x3f,0xf1,0x14,0x14,0x4f,0xf1,0x55,0x55,0x4f,0xc5,0x15,0x54,0x53,0xc9,0x15,0x54,0x63,0xf0,0x55,0x55,0x0f,0xfc,0x55,0x55,0x3f,0xfc,0x45,0x51,0x3f,0xff,0x05,0x50,0xff,0xff,0xf0,0x0f,0xff
};

Player::Player(int x, int y): gx_(x), gy_(y)
{
    px_ = gx_ * TILE_SIZE;
    py_ = gy_ * TILE_SIZE;
    dir_= S;
}

void Player::render()
{
    uint8_t const * sprite;
    uint8_t flags = BLIT_2BPP;
    switch( dir_ ){
        case N:
            sprite= SPRITE_BACK_;
            break;
        case S:
            sprite= SPRITE_FWD_;
            break;
        case E:
            sprite= SPRITE_RIGHT_;
            break;
        case W:
            sprite= SPRITE_RIGHT_;
            flags |= BLIT_FLIP_X;
            break;
    }
    *DRAW_COLORS = 0x0234; // note: bg color of sprite is made transparent
    blit(sprite, px_, py_, 16, 16, flags);
}

void Player::update(int32_t tick)
{
    if( tick % updatePeriod_ != 0 ) return;

    // set point to walk towards
    int32_t sx = gx_*TILE_SIZE;
    int32_t sy = gy_*TILE_SIZE;

    // if idle:
    if( px_ == sx && py_ == sy ){
        // accept new direction to move:
        uint8_t gamepad = *GAMEPAD1;

        // mask the d pad so that pressing multiple keys stops movement
        gamepad &= BUTTON_RIGHT | BUTTON_LEFT | BUTTON_UP | BUTTON_DOWN;
        if( gamepad == BUTTON_RIGHT ){ dir_= E; move_(gx_+1, gy_); }
        if( gamepad == BUTTON_LEFT  ){ dir_= W; move_(gx_-1, gy_); }
        if( gamepad == BUTTON_DOWN  ){ dir_= S; move_(gx_, gy_+1); }
        if( gamepad == BUTTON_UP    ){ dir_= N; move_(gx_, gy_-1); }
    }
    // update set point post movement:
    sx = gx_*TILE_SIZE;
    sy = gy_*TILE_SIZE;

    // walking animation
    if( px_ < sx )      px_ ++;
    else if( px_ > sx ) px_ --;
    else if( py_ < sy ) py_ ++;
    else if( py_ > sy ) py_ --;
}

bool Player::move_(int nx, int ny)
{
    // TODO test position nx, ny is okay to move into or else interact with
    gx_ = nx;
    gy_ = ny;
    return true;
}
