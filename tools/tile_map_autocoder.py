
# take in spritesheet.json and map.json

# onInteraction function which is named in custom property of map.json, and passed to constructor of special tile
# separate object layer including pickups, mobs, etc

import json
import os


def load_tileset(path: str):
    with open(path) as f:
        j = json.load(f)

    image_file = j["image"]  # for calling w4 png2src
    n_columns = j["columns"]
    image_w = j["imagewidth"]
    
    tileset = {}
    for tiledata in j["tiles"]:
        # Get id
        i = tiledata["id"]
        if i > 127:
            raise ValueException("Too many tiles, only <= 127 supported")
    
        # Get tile "type"
        ttype = None
        if "type" in tiledata:
            ttype = tiledata["type"]
        tileset[i] = {"type": ttype}

        # Get properties
        for prop in tiledata["properties"]:
            name = prop["name"]
            value = prop["value"]
            tileset[i][name] = value
    return tileset, n_columns, image_file, image_w


def load_map(path: str):
    with open(path) as f:
        j = json.load(f)
        mapdata = j["layers"]
        first_gid = j["tilesets"][0]["firstgid"]

    obj_data = mapdata[1]["objects"]

    # NOTE: Tiled maps use global id relative to firstgid
    #       but Tiled tilesets use local id relative to 0
    #       to covert, the doc says to subtract the firstgid 
    tile_ids = mapdata[0]["data"]
    tile_ids = [i - first_gid for i in tile_ids]

    # number of tiles in map across
    map_w = mapdata[0]["width"]
    map_h = mapdata[0]["height"]
    return tile_ids, obj_data, map_w, map_h


if __name__ == "__main__":
    # Load tileset
    tileset_path = "res/tileset.json"
    tileset, n_columns, image_file, image_w = load_tileset(tileset_path)
    
    map_path = "res/map.json"
    map_tiles, obj_data, map_w, map_h = load_map(map_path)

    # Write tile type definitions to sprites.auto.hpp, included in sprites.hpp
    with open("src/sprites.defs.auto.hpp", "w") as f:
        f.write(f"// Auto-generated from {tileset_path}\n");
        f.write("#pragma once\n\n")
        f.write("#include <stdint.h>\n\n")
        f.write("namespace sprites {\n\n")
        for tileid in tileset:
            t = tileset[tileid]['type']
            if t:
                f.write(f"uint8_t const {t} = {tileid};\n")
        f.write("\n} // namespace sprites\n")

    print("wrote sprites.defs.auto.hpp")

    # Write spritesheet to spritesheet.auto.hpp
    spritesheet_path = "src/sprites.impl.auto.hpp"
    with open(spritesheet_path, 'w') as f:
        f.write(f"// Autogenerated from {tileset_path}\n")
        f.write(f"#define SPRITES_Columns {n_columns}\n")
    os.system(f"w4 png2src res/{image_file} --c >> {spritesheet_path}")
    os.system(f"sed -i 's/sprites/SPRITES_/g' {spritesheet_path}")
    print(f"wrote {spritesheet_path}")
    
    # Write background layer to map.auto.hpp, included in map.cpp
    with open("src/map.impl.auto.hpp", "w") as f:
        f.write(f"// Auto-generated from {map_path}\n\n")
        f.write("#include <stdint.h>\n\n")
        f.write(f"static const uint8_t MAP_WIDTH = {map_w};\n")
        f.write(f"static const uint8_t MAP_HEIGHT = {map_h};\n")
        f.write(f"static const uint8_t SCREEN_WIDTH = 10;\n")
        f.write(f"static const uint8_t SCREEN_HEIGHT = 10;\n")
        f.write("static const uint8_t TILES[] = {\n")
        for i, tile_id in enumerate(map_tiles):
            # Lookup passability
            passable = tileset[tile_id]["passable"]
            # pack passability and sprite into 8 bits!
            b = tile_id | (int(passable) << 7)
            f.write(f"{b:3d}, ")
            if (i+1) % map_w == 0:
                f.write("\n")
        f.write("};\n")

    print("wrote map.impl.auto.hpp")

    #TODO write object layer
    #print(objdata)
